#include "precomp.h"
#include "zone_map.h"
#include "server_player.h"
#include "server_character.h"
#include "server_gameobject.h"
#include "zone_vicinity_objects.h"

using namespace clan;

ZoneMap::ZoneMap(clan::SqliteConnection &db, const clan::Vec2i &size)
	: db(db), size(size)
{
	tiles.reserve(size.x*size.y);
	clear();
}

ZoneMap::~ZoneMap()
{
}

void ZoneMap::clear()
{
	tiles.clear();
	for(int y = 0; y < size.y; y++)
	{
		for(int x = 0; x < size.x; x++)
		{
			//Clear to a completely opaque, non-walkable block of stone that we can carve our dungeons from.
			auto tile = std::make_shared<ServerMapTile>(Vec2i(x,y), false, false);
			tiles.push_back(tile);
		}
	}
}

void ZoneMap::update(float time_elapsed)
{
}

bool ZoneMap::valid(const Vec2i &position) const
{
	if(position.x < 0 || position.y < 0 || position.x >= size.x || position.y >= size.y)
		return false;
	else
		return true;
}

unsigned int ZoneMap::to_index(const clan::Vec2i &position) const
{
	return position.y*size.x + position.x;
}

void ZoneMap::set_properties(const Vec2i &position, bool transparent, bool walkable, bool architected)
{
	ServerMapTilePtr tile;

	auto index = to_index(position);
	if(index <= tiles.size())
	{
		tile = tiles[index];
		tile->set_position(position);
		tile->set_transparent(transparent);
		tile->set_walkable(walkable);
	}
	else
	{
		//This shouldn't really ever happen :P
		tile = std::make_shared<ServerMapTile>(position, transparent, walkable);
		tiles.push_back(tile);
	}

	//If this tile was architected, then it means it can be regenerated by the seed number of the zone, thus
	//we don't need to store the tile information (it can simply be regenerated from the seed. Otherwise,
	//this tile was changed by an event in the actual game, and the change should indeed be persisted, so that
	//the dungeon can be regenerated later with all the changes to it's features.
	if( !architected )
		dirty_tiles.push_back(tile);
}



bool ZoneMap::is_wall(const clan::Vec2i &position) const
{
	if( !valid(position) )
		return true;

	return tiles[to_index(position)]->is_walkable() == false;
}

bool ZoneMap::can_walk(const clan::Vec2i &position) const
{
	if( is_wall(position) )
		return false;

	//TODO: Iterate over list of all game objects and check for collisions...
	//EDIT: This shouldn't be an iteration over a player's vicinity objects, but 
	//		rather the server's gameobject container. We're the server after all!

	/*auto it = player_map_info.find(player);
	if(it == player_map_info.end())
		return false;

	auto &objects = it->second->vicinity_objects->get_visible_objects();
	for(unsigned int i = 0; i < objects.size(); i++)
	{
		auto go = objects[i];
		
		Vec2i go_position = Vec2i(0,0);
		if(go->hasProperty("Position"))
			go_position = go->get<Vec2i>("Position").get();

		bool tile_blocker = true;
		if(go->hasProperty("TileBlocker"))
			tile_blocker = go->get<bool>("TileBlocker").get();

		//Check if there's a blocking game object in this position,
		//if so, we can't walk there!
		if(tile_blocker && go_position == position)
			return false;
	}*/

	return true;
}

void ZoneMap::clear_dirty_tiles()
{
	dirty_tiles.clear();
}

void ZoneMap::load_from_database()
{
}

void ZoneMap::save_dirty_tiles()
{
	//Should this interact with database_zone_instance, or should it have it's own database_zone_map, or zone_instance_map?
}
